{"name":"tenyr","tagline":"A simple 32-bit computing environment","body":"# tenyr \r\n[![Build Status](https://travis-ci.org/kulp/tenyr.svg?branch=develop)](https://travis-ci.org/kulp/tenyr)\r\n\r\n## Overview\r\n\r\n**tenyr** is a 32-bit computer architecture and computing environment that\r\nfocuses on simplicity of design and implementation. **tenyr** comprises :\r\n\r\n* an [instruction set architecture (ISA)](https://github.com/kulp/tenyr/wiki/Assembly-language)\r\n* an [implementation in FPGA hardware](https://github.com/kulp/tenyr/tree/develop/hw/verilog) with device support\r\n* tools for building software\r\n  * [assembler (tas)](https://github.com/kulp/tenyr/wiki/Assembler)\r\n  * linker (tld)\r\n  * [simulator (tsim)](https://github.com/kulp/tenyr/wiki/Simulator)\r\n* a [standard library](https://github.com/kulp/tenyr/tree/develop/lib) of tenyr code\r\n* some [example software](https://github.com/kulp/tenyr/tree/develop/ex), including :\r\n  * a [timer](https://github.com/kulp/tenyr/blob/develop/ex/clock.tas.cpp)\r\n  * [random snakes](https://github.com/kulp/tenyr/blob/develop/ex/bm_snake.tas.cpp)\r\n  * a [recursive Fibonacci number generator](https://github.com/kulp/tenyr/blob/develop/ex/bm_fib.tas.cpp)\r\n  \r\nSomeday it will also include :\r\n\r\n* a C compiler based on LCC\r\n* [a Forth environment](https://github.com/kulp/tenyr/tree/develop/forth)\r\n* a novel operating system\r\n\r\nExplore a [simple online demo of the **tenyr** toolset](http://demo.tenyr.info/).\r\n\r\nThis page serves as a general overview of the design of **tenyr**. It\r\nis not an exhaustive reference. An older version of some of this\r\ndocumentation, perhaps in some ways more complete, can be found [on the\r\n**tenyr** wiki](https://github.com/kulp/tenyr/wiki).\r\n\r\n---\r\n\r\n## Description\r\n\r\n### Assembler Syntax and Machine Model\r\n\r\n#### Registers\r\n\r\n**tenyr** has sixteen registers, named `A` through `P`. Refer to them\r\nusing their uppercase or lowercase names ; **tenyr** tools are not\r\ncase-sensitive. Two of these registers, `A` and `P`, are special, while\r\nthe others are completely general purpose. All registers are 32 bits\r\nwide, and are treated as two's-complement signed integers everywhere\r\nthat makes sense (there are no unsigned 32-bit integers in **tenyr**,\r\njust signed integers and bitstrings).\r\n\r\n#### Instruction Format\r\n\r\nEvery **tenyr** instruction can be expressed in a single, regular,\r\nalgebraic instruction format :\r\n\r\n```\r\nZ <- _ op _ + _\r\n```\r\n\r\nwhere `Z` is a register, `op` is one of the accepted arithmetic\r\noperations, `+` is addition, two of the blanks are registers, and\r\none of the blanks is an immediate value (a integer) between -2048 and\r\n2047. Any one of the blanks and the operation that goes before it can\r\nbe left out. Examples :\r\n\r\n```\r\na <- a + a + 0\r\nb <- c * d + 3\r\nc <- d - e + -2\r\nd <- e ^ f\r\ne <- f - 2\r\nf <- 2 | g\r\ng <- -h\r\nh <- i <> 0\r\ni <- j < k\r\nj <- k\r\n```\r\n\r\n#### Operations\r\n\r\nHere are the operations that **tenyr** supports :\r\n\r\n Syntax         | Description\r\n:--------------:|:-------------------\r\n <code>B <- C  &#124;  D</code> | C bitwise or D\r\n `B <- C  &  D` | C bitwise and D\r\n `B <- C  +  D` | C add D\r\n `B <- C  *  D` | C multiply D\r\n `B <- C <<  D` | C shift left D\r\n `B <- C  <  D` | C test less than D\r\n `B <- C ==  D` | C test equal to D\r\n `B <- C >=  D` | C test greater than or equal to D\r\n `B <- C  &~ D` | C bitwise and complement D\r\n `B <- C  ^  D` | C bitwise xor D\r\n `B <- C  -  D` | C subtract D\r\n `B <- C  ^~ D` | C xor ones' complement D\r\n `B <- C >>  D` | C shift right logical D\r\n `B <- C <>  D` | C test not equal to D\r\n `B <- C >>> D` | C shift right arithmetic D\r\n\r\nSome of the operations merit explanation. The comparison operations\r\n(`<`, `>=`, `==`, and `<>`) produce a result that is either `0` (false)\r\nor `-1` (true). The canonical truth value in **tenyr** is `-1`, not\r\n`1`. This allows us to do clever things with masks, and also explains\r\nthe existence of the special `&~` and `^~` operations -- when the second\r\noperand is a truth value, the bitwise complement works as a Boolean\r\nNOT. The operations also underlie some syntactical sugar ; for example,\r\n`B <- ~C` is accepted by the assembler and transformed into `B <- C ^~ A`.\r\n\r\n#### Memory Operations\r\n\r\nA memory operation looks just like a register-register operation, but\r\nwith one side of the instruction dereferenced, using brackets :\r\n\r\n```\r\n d  <- [e * 4 + f]    // a load into D\r\n e  -> [f << 2]       // a store from E\r\n[f] <- 2              // another kind of store, with an immediate value\r\n```\r\n\r\nOne instruction can't have brackets on both sides of an arrow, and an\r\nimmediate value cannot appear on the left side of an arrow. Otherwise,\r\nmost anything that makes sense using the operations that are valid in\r\n**tenyr** should be possible.\r\n\r\n#### Instruction Shorthand\r\n\r\nAlthough pieces of the right-hand-side of an instruction can be left\r\nout during assembly, under the covers all the pieces are still there ;\r\nthe missing parts are filled in with zeros or with references to the\r\nspecial `A` register, which always contains `0`, even if it is written\r\nto. Therefore, each instruction in the following pairs is identical to\r\nthe other one in the pair :\r\n\r\n```\r\nb <- 3      ; b <- a +  a + 3\r\nc <- d *  e ; c <- d *  e + 0\r\ne <- 1 << b ; e <- 1 << b + a\r\n```\r\n\r\nTo see the expanded form, invoke the disassembler (`tas -d`) with the\r\n`-v` option.\r\n\r\n#### Control Flow\r\n\r\n**tenyr** has no dedicated control-flow instructions ; flow is\r\ncontrolled by updating the `P` register, which is the program counter /\r\ninstruction pointer. Reading from `P` will produce the address of the\r\ncurrently executing instruction, plus one. Writing to it will cause the\r\nnext instruction executed to be fetched from the address written into\r\n`P`. For example, if this program starts at address 0 :\r\n\r\n```\r\nB <- P        // after this instruction, B contains 1\r\nD <- 3        // after this instruction, D contains 3\r\nP <- P - 3    // this is a loop back to the first instruction above\r\n```\r\n\r\nNotice that in the third instruction it was necessary to subtract 3\r\ninstead of 2, because the value in `P` was effectively the location of\r\nthe *next* instruction that would have been executed in the absence of\r\na control flow change.\r\n\r\nUnder normal circumstances, the programmer is not expected\r\nto update the `P` register in such a direct fashion,\r\nbut rather to use a macro like `jnzrel(reg,target)` from\r\n[common.th](https://github.com/kulp/tenyr/blob/develop/lib/common.th) :\r\n\r\n```\r\n    D <- 5\r\n    C <- 10\r\nloop_top:\r\n    C < C - 1\r\n    N <- C > D\r\n    jnzrel(N,loop_top)\r\n```\r\n\r\nwhere `loop_top` is a label to jump to, and `jnzrel` means \"jump if not\r\nzero to relative\" (admittedly, this is not a very good name, because\r\n`N` needs to be `-1` not merely nonzero).\r\n\r\nNotice that we used `>` even though this is not one of the supported\r\noperations. The assembler accepts `>` and rewrites it into a valid\r\n**tenyr** instruction by swapping the order of the operands and using\r\n`<` instead. An analogous transformation occurs for `<=`.\r\n\r\n#### Special instructions\r\n\r\nThere is currently one special instruction, written as `illegal`\r\n; it stops program execution in the simulator. It is currently not\r\nimplemented in hardware (use an infinite loop instead, such as `P <- P -\r\n1`). Eventually it will be a specific case of a more generic exception\r\nmechanism, but for now it is the only \"trap\" instruction **tenyr** has.\r\n\r\n#### Labels\r\n\r\nLabels can be used to identify segments of code and data. A label\r\nis defined by a sequence of alphanumeric characters and underscores,\r\nwhere that sequence cannot look like a register name (this restriction\r\nmay be relaxed in the future). A label is referred to by prefixing `@`\r\nto its name :\r\n\r\n```\r\ndata:\r\n    .word 0xdeadbeef\r\ntop:\r\n    B <- C\r\n    D <- @data\r\n    E <- @top\r\n```\r\n\r\nGetting the value of `@label` isn't very useful, though, because\r\nthat value is relative to where the code was loaded in memory. So if\r\ncode was loaded at the default address of `0x1000`, one would need to\r\nadd `0x1000` to `@data` to get the absolute value in memory. This is\r\neasier when using the special label `.` ; then the expression `P - .`\r\nwill be the loading offset. This is handled by the `rel()` macro from\r\n[common.th](https://github.com/kulp/tenyr/blob/develop/lib/common.th).\r\nThink of `rel()` as producing a \"relocated\" address from a relative one.\r\n\r\n#### Immediates\r\n\r\nImmediate values are 12 bits wide, thus ranging from -2048 to 2047. ASCII\r\n(the ASCII subset of UTF-32, really) character constants can appear in\r\nimmediate expressions :\r\n\r\n```\r\nB <- '$'\r\nC <- 4\r\n```\r\n\r\nAn immediate value can also be an expression with multiple terms, as\r\nlong as :\r\n\r\n1. all of the terms are constants\r\n2. the entire expression is enclosed in parentheses\r\n3. a `@label` reference occurs at most once\r\n\r\nThe result of an immediate expression is computed in the assembler,\r\nand only the resulting immediate value is written out. Many of the\r\n**tenyr** operations can be used in immediate expressions, too, as well\r\nas one that isn't available : integer division, with `/`. Be aware that\r\ncurrently there is no operator precedence within an immediate expression ;\r\nexpressions are evaluated left-to-right.\r\n\r\n```\r\nB <- B ^ ('A' ^ 'a')  // flip capitalisation of the character in B\r\nC <- ((124 - 1) | 1)  // after this instruction, C will contain the value 123\r\nD <- (8 / 4)          // D will contain 2\r\nE <- (16 - 8 / 4)     // E will contain 2, not 14\r\n```\r\n\r\n#### Directives\r\n\r\nThere are a few assembly directives to make assembly easier :\r\n\r\n```\r\n.word 0, 1, 2, 0x1234, 'A', 'B'    // each value is expanded to a 32-bit word\r\n.utf32 \"Hello, world\"              // each character is saved in a 32-bit word\r\n.zero 0x14                         // this creates 0x14 = 20 zeros in a row\r\n```\r\n\r\n### Caveats\r\n\r\nIt is intended that disassembling a program and reassembling it will\r\nproduce an identical binary, but this is not yet guaranteed. Because\r\nmost word-sized bit-patterns are valid **tenyr** instructions, and\r\nbecause the default disassembly of a constant value might be reassembled\r\nas a different value, it is recommended to use `-v` to produce verbose\r\ndisassembly if reassembly is intended. File a bug on any situation where\r\nan assembler-disassembler-assembler round-trip does not produce identical\r\noutput on each round.\r\n","google":"UA-25274107-2","note":"Don't delete this file! It's used internally to help with page regeneration."}